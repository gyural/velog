<h3 id="집중했던-사항들">집중했던 사항들</h3>
<p>✅ 주차장 데이터는 엄청 많을 것이고 이중 정말 최소한 만을 저장할 것이다.
✅ 현재 주차장과 앱 디비의 연결다리 역할 인만큼 데이터 정합성이 정말 중요하다.
✅ 가벼운 스펙으로 만들기 때문에 연산 최적화가 필요하다.
✅ 경제적 리소스 최적화</p>
<h2 id="atlas에-몇개까지-들어가요">Atlas에 몇개까지 들어가요???</h2>
<p>512MB의 저장 용량까지 프리티어에서 허용함
이를 기준으로 sync-log 테이블에 몇 개의 행이 들어갈 수 있을지를 추정해본다면... 
각 행의 크기를 추정,sync-log 테이블에 포함될 수 있는 필드는 다음과 같음</p>
<pre><code>1.    entry_id (String): 외부 DB에서의 레코드 ID. 일반적으로 24바이트의 문자열
2.    last_sync_time (DateTime): 동기화한 시간. MongoDB에서는 Date 객체가 8바이트를 차지
3.    is_updatable (Boolean): 데이터 업데이트 가능 여부. 이 값은 1바이트로 충분합니다.
4.    sync_status (String): 동기화 상태(성공/실패). 일반적으로 “success”, “failure” 등 몇 글자일 수 있습니다. 예를 들어, 20바이트로 가정할 수 있습니다.</code></pre><p>이 값을 바탕으로 각 행의 대략적인 크기를 계산해보면...</p>
<p>*<em>각 행의 크기
*</em>    •    entry_id (24바이트)
    •    last_sync_time (8바이트)
    •    is_updatable (1바이트)
    •    sync_status (20바이트)</p>
<p>따라서 각 행의 크기는 약 53바이트 정도로 예상</p>
<p>512MB로 예상되는 저장 가능한 행 수</p>
<p>1MB = 1024KB, 1KB = 1024바이트, 따라서 512MB는 512 * 1024 * 1024 = 536,870,912바이트입니다.</p>
<p>1행당 약 53바이트를 차지하므로, 512MB에 저장할 수 있는 행 수는:</p>
<blockquote>
<p>결과 약 1천만 개 이상의 행을 저장할 수 있음</p>
</blockquote>
<p>물론, 인덱스나 추가적인 메타데이터가 포함될 수 있으므로 실제 저장 용량은 더 적을 수 있습니다. 하지만 기본적인 계산으로는 약 1천만 개의 행을 충분히 저장할 수 있을 것으로 보입니다.</p>
<h1 id="최종-아키텍처">최종 아키텍처</h1>
<h2 id="sync-server-아키텍처">Sync Server 아키텍처</h2>
<h3 id="1-목표">1. 목표</h3>
<p>_    이전 스케줄러 발동 시간 기준입니다..._</p>
<p><strong>1) 외부 DB와 동기화를 통해 최신 데이터를 앱 서버로 전달.
2) 업데이트 된 사항이 있다면 변경 사항을 앱 서버로 전달.</strong>
    --&gt; 주차 데이터 특성상 업데이트 가능한 경우는 입차 후 출차가 안되었을 때 이며, 이때만 MongoDB에 저장해줍니다....!!!</p>
<h3 id="2-구성-요소">2. 구성 요소</h3>
<p><code>DBMS</code> Atlas + MongoDB
쉬운 접속과 인프라 구축을 위해 사용해 줬습니다.
<code>Language</code> JAVA8
TLS1.0 프로토콜을 사용하기 위해 사용했습니다.
<code>FrameWork</code> Spring 2.4.X
JAVA8과 의 호환성때문에 사용했습니다.</p>
<h3 id="3-메인-프로세스">3. 메인 프로세스</h3>
<blockquote>
<p>Section은 2개로 나뉩니다.</p>
</blockquote>
<p><strong>Section1</strong> 새로운 데이터 동기화</p>
<p>1) Batch Size에 맞는 새로운 데이터 주차장 DB에서 입차 기록 READ 🔍
2) 위의 입차 데이터의 대응되는 출차기록 주차장 DB에서 READ 🔍 
3) 대응 되는 짝끼리 DTO안에서 합 🤝
4) 해당 DTO리스트를 APP Server로 POST ✉️ 
5) 응답으로 유효한 데이터(회원 데이터)만 RESPONSE ✉️ 
6) 유효한 데이터 중 업데이트가능한 == 이후 출차가능한 데이터만 MongoDB에 WRITE📝</p>
<p><strong>Section2</strong> Updatable 데이터 동기화</p>
<p>1) MongoDB에서 업데이트가능한(출차가능) DATA 전체 READ 🔍
2) 해당 엔티티리스트의 ID리스트를 통해 MS DB(최신 데이터)를 READ 🔍
3) 이전 데이터(Mongo) 최신데이터(MS) 비교를 통해 업데이트 된 데이터 DETECT🕵️
4) DETECT된 데이터 리스트를 APP Server로 POST ✉️
5) 정상 동기화 완료후 저장된 ID 리스트를 RESPONSE ✉️
6) RESPONSE에 포함된 ID를 가지는 엔티티 MongoDB에서 DELETE 🗑️</p>
<h3 id="4-서버간-인증인가">4. 서버간 인증인가</h3>
<p><a href="https://github.com/Team-Devmon-IN-KU/HonorsParking-BE">메인서버</a>에서는 이미 세션방식의 인증인가를 사용합니다.
하지만 DB동기화를 위해 로그인을 하는 것은 오버헤드라고 판단해서
동기화를 위한 URL만 API key방식으로 동작시킬 예정입니다.</p>
<hr />
<h1 id="결론">결론</h1>
<p>DB동기화가 단순히 읽어와서 요청만 보내면 된다고 생각했던 것은 큰 오산이었다...
이번 기회에 설계의 중요성을 다시 느끼고 단순한 로직이라도 꼼꼼히 설계후 구현 단계에 들어가야겠다는 생각을 절실히 했다.</p>