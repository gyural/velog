<p><em>O(n)과 O(log n)의 성능 차이를 실생활 예시를 들어 설명하고, 데이터의 크기가 1백만 개일 때 각각 대략 몇 번의 연산이 필요한지 비교해주세요.</em></p>
<h1 id="1-실생활에서-찾아볼-수-있는-on">1. 실생활에서 찾아볼 수 있는 O(n)</h1>
<p>O(n)은 순차적으로 무언가를 찾을 때 발생하는 시간복잡도입니다.
실생활 에서는 책에서 원하는 구절을 1page 부터 999page까지 순차적으로 탐색하는 예시가 있습니다.
이는 책의 페이지가 <strong>N 페이지</strong>라면 탐색에 걸리는시간은 <strong>최악의 경우 O(N)</strong>입니다. 
즉 <strong>Big O 로 표기한다면 O(N)</strong>의 시간이 걸리는 예시입니다.</p>
<p>만약 데이터의 크기 N이 100만이라면 최악의 경우 100만번의 연산을 그대로 해야할 것입니다.</p>
<h1 id="2-실생활에서-찾아볼-수-있는-olog-n">2. 실생활에서 찾아볼 수 있는 O(log n)</h1>
<p>가장 이해하기 쉬운 예시는 Up🔺 Down🔻게임입니다. 해당 게임은 원하는 숫자를 맞출 때
물어본 숫자가 목표 숫자보다 크면 UP🔺 작으면 Down🔻이라는 답을 들으며 목표 숫자를 추적해내는 게임입니다.</p>
<p>만약 목표숫자가 55이고 범위가 1~100이라면</p>
<blockquote>
<p>50 -&gt; UP🔺
75 -&gt; Down🔻
.
.
.
55 -&gt; Correct</p>
</blockquote>
<h3 id="그렇다면-up-down게임에서-시간-복잡도는">그렇다면 Up Down게임에서 시간 복잡도는?</h3>
<p>숫자를 찾아가는 과정은 트리 형태입니다...!!
그리고 이때 최악의 경우 트리  가장 밑 하단까지 가야할 것입니다.</p>
<p><code>트리 모형</code></p>
<blockquote>
<pre><code>                            [50]
                           /    \
                     UP🔺/        \Down🔻
                       /            \
                    [75]            [25]
                  /     \          /     \
         Down🔻 /       \UP🔺  Down🔻/       \UP🔺
              [62]     [68]     [12]     [37]
             /   \     ...     ...       ...
     Down🔻 /     \UP🔺
          [56]   [59]
         /   \
 Down🔻 /     \Correct🎯
      [53]   [55]</code></pre></blockquote>
<p>이 때 트리의 높이는 <code>log(100) ≈ 6.6</code>
최대 7번의 탐색을 해야합니다..!!
즉 N개의 숫자가 주어졌다면 시간 복잡도는 O(log2(N)) = O(log N)입니다.
대부분 O(log N)으로 표기하는데 트리가 가질 수 있는 <strong>자식에 따라서 log의 밑이 달라집니다.</strong></p>
<p>만약 데이터의 크기 N이 100만이라면 최악의 경우 log2(100) ≈ 19.9
20번의 연산이 일어날 것입니다.</p>
<p>O(N)과 엄청 차이나네요!!!</p>
<p><img alt="" src="https://velog.velcdn.com/images/gyural/post/44eb20f1-bb0e-484c-b443-cff5c82c1ecf/image.png" />
(Mac에서는 간단한 계산을 쉽게 해볼 수 있어서 좋네요..!! 😀)</p>